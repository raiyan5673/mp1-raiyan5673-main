import 'util/stats.dart';

/// Base class for all process types.
abstract class Process {
  final String name;
  Process(this.name);

  /// Returns a list of all events generated by this process.
  List<Event> generateEvents();
}

/// A single event in the system.
class Event {
  final String processName;
  final double arrival;
  final double duration;

  // Filled in by the simulator
  double start = 0.0;
  double wait = 0.0;

  Event(this.processName, this.arrival, this.duration);
}

/// Generates one event at a fixed arrival time with a fixed duration.
class SingletonProcess extends Process {
  final double duration;
  final double arrival;
  SingletonProcess(String name, {required this.duration, required this.arrival}) : super(name);

  @override
  List<Event> generateEvents() => [Event(name, arrival, duration)];
}

/// Generates multiple fixed-duration events separated by a fixed interarrival time.
class PeriodicProcess extends Process {
  final double duration;
  final double interarrival;
  final double firstArrival;
  final int repetitions;

  PeriodicProcess(String name,
      {required this.duration,
      required this.interarrival,
      required this.firstArrival,
      required this.repetitions})
      : super(name);

  @override
  List<Event> generateEvents() {
    final events = <Event>[];
    double t = firstArrival;
    for (int i = 0; i < repetitions; i++) {
      events.add(Event(name, t, duration));
      t += interarrival;
    }
    return events;
    }
}

/// Generates events with exponential durations and interarrival times.
class StochasticProcess extends Process {
  final double meanDuration;
  final double meanInterarrival;
  final double firstArrival;
  final double endTime;
  final int? seed;

  StochasticProcess(String name,
      {required this.meanDuration,
      required this.meanInterarrival,
      required this.firstArrival,
      required this.endTime,
      this.seed})
      : super(name);

  @override
  List<Event> generateEvents() {
    final events = <Event>[];
    final durExp = ExpDistribution(mean: meanDuration, seed: seed ?? 0);
    final gapExp = ExpDistribution(mean: meanInterarrival, seed: (seed ?? 0) + 1);

    double t = firstArrival;
    while (t <= endTime) {
      // Many assignments treat time as integer units; rounding the samples
      // keeps output readable while preserving expectations.
      final durationSample = durExp.next().roundToDouble();
      // Ensure strictly positive service times (avoid potential 0 from rounding)
      final duration = durationSample <= 0 ? 1.0 : durationSample;

      events.add(Event(name, t, duration));
      final gap = gapExp.next().roundToDouble();
      t += (gap <= 0 ? 1.0 : gap);
    }
    return events;
  }
}
